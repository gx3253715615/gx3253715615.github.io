<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>HelloW | Sanjin Blog</title><meta name="author" content="Sanjin"><meta name="copyright" content="Sanjin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 线程状态1.1 线程状态:状态被定义在了java.lang.Thread.State枚举类中，State枚举类的源码如下： 123456789101112131415161718192021222324252627282930public class Thread &#123;        public enum State &#123;            &#x2F;* 新建 *&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="HelloW">
<meta property="og:url" content="http://example.com/2023/12/01/HelloW/index.html">
<meta property="og:site_name" content="Sanjin Blog">
<meta property="og:description" content="1. 线程状态1.1 线程状态:状态被定义在了java.lang.Thread.State枚举类中，State枚举类的源码如下： 123456789101112131415161718192021222324252627282930public class Thread &#123;        public enum State &#123;            &#x2F;* 新建 *&#x2F;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2023-11-30T16:07:05.000Z">
<meta property="article:modified_time" content="2024-11-30T16:09:44.367Z">
<meta property="article:author" content="Sanjin">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/12/01/HelloW/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'HelloW',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">1</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Sanjin Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">HelloW</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">HelloW</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-30T16:07:05.000Z" title="发表于 2023-12-01 00:07:05">2023-12-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-30T16:09:44.367Z" title="更新于 2024-12-01 00:09:44">2024-12-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="1-线程状态"><a href="#1-线程状态" class="headerlink" title="1. 线程状态"></a>1. 线程状态</h1><h2 id="1-1-线程状态"><a href="#1-1-线程状态" class="headerlink" title="1.1 线程状态:"></a>1.1 线程状态:</h2><p>状态被定义在了java.lang.Thread.State枚举类中，State枚举类的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/* 新建 */</span></span><br><span class="line">        NEW , </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 可运行状态 */</span></span><br><span class="line">        RUNNABLE , </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 阻塞状态 */</span></span><br><span class="line">        BLOCKED , </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 无限等待状态 */</span></span><br><span class="line">        WAITING , </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 计时等待 */</span></span><br><span class="line">        TIMED_WAITING , </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 终止 */</span></span><br><span class="line">        TERMINATED;</span><br><span class="line">    </span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前线程的状态</span></span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jdk.internal.misc.VM.toThreadState(threadStatus);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一共存在6种状态, 还有一种没有给出但应该要加进去的Running状态</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>新建（New)</td>
<td>程已创建，但尚未启动。未调用start()</td>
</tr>
<tr>
<td>就绪（Runnable)</td>
<td>线程已经启动，处于等待操作系统调度的状态</td>
</tr>
<tr>
<td>运行（Running）</td>
<td>线程正在运行中</td>
</tr>
<tr>
<td>阻塞（Blocked）</td>
<td>线程因为等待获取锁而无法继续执行</td>
</tr>
<tr>
<td>等待（Waiting）</td>
<td>线程等待其他线程的通知或某个特定事件的发生</td>
</tr>
<tr>
<td>计时等待（Timed Waiting）</td>
<td>线程在指定时间内等待，直到时间到达</td>
</tr>
<tr>
<td>终止（Terminated）</td>
<td>线程执行完成或被终止</td>
</tr>
</tbody></table>
<h2 id="1-2-线程状态之间的转换"><a href="#1-2-线程状态之间的转换" class="headerlink" title="1.2 线程状态之间的转换"></a>1.2 线程状态之间的转换</h2><p>状态转换如图:</p>
<p><img src="https://i-blog.csdnimg.cn/direct/82bbe2f700f549dcb166e1ad9b529539.png" alt="在这里插入图片描述"></p>
<p><code>Thread</code>类中涉及到的方法:<br><img src="https://i-blog.csdnimg.cn/direct/c8fee46c69044736ab6bca166b137a04.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/direct/3d0f477b3e2249b580e7d5c9cad04575.png" alt="在这里插入图片描述"><img src="https://i-blog.csdnimg.cn/direct/e09794a4205a452092f93e5de2d26ad8.png" alt="在这里插入图片描述"></p>
<p><code>object</code>类涉及到的方法:<br><img src="https://i-blog.csdnimg.cn/direct/aba2550655644dd0931603c1320367f7.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/direct/009c531b64a64ef3a3ea46ebbeff5c7e.png" alt="在这里插入图片描述"></p>
<h2 id="1-3-实例代码"><a href="#1-3-实例代码" class="headerlink" title="1.3 实例代码"></a>1.3 实例代码</h2><p><strong>Block状态(synchronized锁)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedResource</span> &#123;</span><br><span class="line">    <span class="comment">// 共享资源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">access</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is accessing the resource.&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);  <span class="comment">// 模拟操作</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockToRunnableExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SharedResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SharedResource</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource) &#123;</span><br><span class="line">                resource.access();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread 1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource) &#123;</span><br><span class="line">                resource.access();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>waiting状态(使用 Object.wait() 和 notify() 的示例)</strong></p>
<blockquote>
<p>如果有多个线程在同一个对象上调用 <code>wait()</code>，<code>notify()</code> 只会唤醒其中的一个线程。这个线程是<strong>随机</strong>的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedResource</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;  <span class="comment">// 控制线程间通信的标志</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            wait();  <span class="comment">// 等待消费者消费后再生产 进入waiting状态等待被唤醒</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Produced item&quot;</span>);</span><br><span class="line">        flag = <span class="literal">true</span>;  <span class="comment">// 标记为已生产</span></span><br><span class="line">        notify();  <span class="comment">// 唤醒消费者</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">            wait();  <span class="comment">// 等待生产者生产</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumed item&quot;</span>);</span><br><span class="line">        flag = <span class="literal">false</span>;  <span class="comment">// 标记为已消费</span></span><br><span class="line">        notify();  <span class="comment">// 唤醒生产者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitingToRunnableExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">SharedResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SharedResource</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    resource.produce();</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);  <span class="comment">// 模拟生产间隔</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    resource.consume();</span><br><span class="line">                    Thread.sleep(<span class="number">1500</span>);  <span class="comment">// 模拟消费间隔</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">        producer.join();</span><br><span class="line">        consumer.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>waiting状态(Thread.join()的实例)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitingToRunnableJoinExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 1 finished.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 主线程等待 t1 结束</span></span><br><span class="line">        t1.join();  <span class="comment">// 主线程进入等待状态，直到 t1 完成</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread finished.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Timed waiting类似</p>
<h1 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2. 线程池"></a>2. 线程池</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>线程池存在的意义：创建一个线程的成本是比较高的, 如果没有线程池需要频繁的创建和销毁线程</p>
<h2 id="2-2-自定义线程池"><a href="#2-2-自定义线程池" class="headerlink" title="2.2 自定义线程池"></a>2.2 自定义线程池</h2><h3 id="2-2-1-线程池的工作原理-跟生产消费模型类似-："><a href="#2-2-1-线程池的工作原理-跟生产消费模型类似-：" class="headerlink" title="2.2.1 线程池的工作原理(跟生产消费模型类似)："></a>2.2.1 线程池的工作原理(跟生产消费模型类似)：</h3><ol>
<li><strong>任务容器</strong>：线程池中的 <strong>任务容器</strong> 就像一个共享资源容器，里面存放着需要执行的任务。这些任务可能是从外部提交进来的，或者是线程池的工作线程需要处理的。</li>
<li><strong>消费者线程</strong>：线程池会 <strong>预先创建一定数量的工作线程（消费者线程）</strong>，这些线程是从一开始就存在的，并且会一直循环使用。你提到的 <strong>2个消费者线程</strong> 就是这个线程池的初始工作线程数。</li>
<li><strong>等待任务</strong>：当线程池的消费者线程没有任务可做时，它们会进入 <strong>等待状态</strong>（<code>wait()</code>）。这和生产者消费者模型中的消费者线程类似：消费者线程在等待任务的到来。</li>
<li><strong>任务的到来</strong>：当外部线程将 <strong>一个任务放入任务容器中</strong> 时，任务容器会触发 <strong>唤醒一个等待的线程</strong>（使用 <code>notify()</code> 或 <code>notifyAll()</code>）。这时，等待的消费者线程就会从 <strong>等待状态</strong>（<code>wait()</code>）转变为 <strong>就绪状态</strong>（<code>Runnable</code>），并开始执行任务。</li>
<li><strong>执行任务</strong>：消费者线程会从任务容器中取出一个任务并执行，执行完毕后，它会 <strong>继续等待</strong> 下一个任务的到来。如果任务容器中有其他任务，它会继续执行，直到没有任务为止。</li>
</ol>
<h3 id="2-2-2-代码实现"><a href="#2-2-2-代码实现" class="headerlink" title="2.2.2 代码实现"></a>2.2.2 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">myThreadPool</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">myThreadPool</span>(<span class="number">2</span>);</span><br><span class="line">        threadPool.submit(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 看看是否是多个线程在执行任务</span></span><br><span class="line">            System.out.println(<span class="string">&quot;执行第一个任务&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;完成第一个任务&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadPool.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行第二个任务&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;完成第二个任务&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadPool.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行第三个任务&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;完成第三个任务&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// main线程等待10秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">10000</span>);&#125; <span class="keyword">catch</span> (Exception e) &#123;System.out.println(e.getMessage());&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义线程池</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Runnable&gt; taskQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> poolSize; <span class="comment">// 运行线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> workThread[] workThreads; <span class="comment">// 线程池中的线程集合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">myThreadPool</span><span class="params">(<span class="type">int</span> poolSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.poolSize = poolSize;</span><br><span class="line">        workThreads = <span class="keyword">new</span> <span class="title class_">workThread</span>[poolSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            workThreads[i] = <span class="keyword">new</span> <span class="title class_">workThread</span>();</span><br><span class="line">            workThreads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// synchronized确保线程安全, 因为操作了共享变量(taskQueue) 还有在使用wait和notify这个方法时需要加锁 否则系统抛出异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">        taskQueue.addLast(task);</span><br><span class="line">        <span class="comment">// 随机唤醒一个等待中的线程</span></span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (taskQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 当前线程进入waiting状态</span></span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> taskQueue.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">workThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="comment">// 不断获取任务队列中的任务</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 线程不能停</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> getTask();</span><br><span class="line">                    <span class="comment">// 由当前线程执行这个任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果:</p>
<p><img src="https://i-blog.csdnimg.cn/direct/0ebc60c01e6e4f938907368652cf478e.png" alt="在这里插入图片描述"></p>
<h2 id="2-3-JDK中的线程池"><a href="#2-3-JDK中的线程池" class="headerlink" title="2.3 JDK中的线程池"></a>2.3 JDK中的线程池</h2><h3 id="2-3-1-Executors"><a href="#2-3-1-Executors" class="headerlink" title="2.3.1 Executors"></a>2.3.1 Executors</h3><p>JDK对线程池也进行了相关的实现，很少去自定义线程池，而是使用JDK中自带的线程池。</p>
<p>可以使用Executors中所提供的<strong>静态</strong>方法来创建线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建一个固定大小的线程池</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">特点：</span></span><br><span class="line"><span class="comment">  池中线程数量固定为 nThreads</span></span><br><span class="line"><span class="comment">  如果线程处于空闲状态，会被复用</span></span><br><span class="line"><span class="comment">  如果所有线程都在忙碌，新任务将被放入队列等待执行</span></span><br><span class="line"><span class="comment">适用场景：适合执行长期任务，性能较稳定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">fixedPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">fixedPool.execute(() -&gt; System.out.println(<span class="string">&quot;任务1&quot;</span>));</span><br><span class="line">fixedPool.execute(() -&gt; System.out.println(<span class="string">&quot;任务2&quot;</span>));</span><br><span class="line">fixedPool.shutdown(); <span class="comment">// 平滑关闭线程池: a.已提交的任务会继续执行 b.不允许提交新的任务 c.所有任务完成后，线程池会完全关闭</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建一个单线程的线程池</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">特点：</span></span><br><span class="line"><span class="comment">   始终只有一个线程在执行任务</span></span><br><span class="line"><span class="comment">   保证任务按照提交的顺序（FIFO、LIFO、优先级）执行</span></span><br><span class="line"><span class="comment">适用场景：适合需要任务逐一执行的场景</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">singleThreadPool</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">singleThreadPool.execute(() -&gt; System.out.println(<span class="string">&quot;任务1&quot;</span>));</span><br><span class="line">singleThreadPool.execute(() -&gt; System.out.println(<span class="string">&quot;任务2&quot;</span>));</span><br><span class="line">singleThreadPool.shutdown();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.创建一个可缓存的线程池</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">特点：</span></span><br><span class="line"><span class="comment">   线程数量不固定，可根据需要创建新线程</span></span><br><span class="line"><span class="comment">   空闲线程会在 60 秒后被回收</span></span><br><span class="line"><span class="comment">   如果线程较多但任务少，资源消耗大</span></span><br><span class="line"><span class="comment">适用场景：适合执行大量的短期任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">cachedPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">cachedPool.execute(() -&gt; System.out.println(<span class="string">&quot;任务1&quot;</span>));</span><br><span class="line">cachedPool.execute(() -&gt; System.out.println(<span class="string">&quot;任务2&quot;</span>));</span><br><span class="line">cachedPool.shutdown();</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.创建一个支持定时任务或周期性任务的线程池</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">特点：</span></span><br><span class="line"><span class="comment">   核心线程池大小为 corePoolSize</span></span><br><span class="line"><span class="comment">   支持 schedule() 方法来延时执行任务</span></span><br><span class="line"><span class="comment">   支持 scheduleAtFixedRate() 和 scheduleWithFixedDelay() 来周期性执行任务</span></span><br><span class="line"><span class="comment">适用场景：适合需要定时或周期性运行的任务 例如:定时备份、定时发送报告或监控任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">scheduledPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 延迟3s执行</span></span><br><span class="line">scheduledPool.schedule(() -&gt; System.out.println(<span class="string">&quot;延迟执行任务&quot;</span>), <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 以固定频率执行(如果这个周期内没有执行完, 将直接开启下一个周期, 可能导致任务堆积(任务没有执行完))</span></span><br><span class="line">scheduledPool.scheduleAtFixedRate(() -&gt; System.out.println(<span class="string">&quot;周期性任务&quot;</span>), <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 以固定延迟执行(如果这个周期内没有执行完, 下一个周期将会被延迟, 不会导致任务堆积)</span></span><br><span class="line">scheduledPool.scheduleWithFixedDelay(() -&gt; System.out.println(<span class="string">&quot;延迟固定间隔任务&quot;</span>), <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">scheduledPool.shutdown();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.创建一个单线程的定时任务线程池</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">特点：</span></span><br><span class="line"><span class="comment">   只有一个线程</span></span><br><span class="line"><span class="comment">   支持 scheduleAtFixedRate() 和 scheduleWithFixedDelay() 来周期性执行任务</span></span><br><span class="line"><span class="comment">   用于顺序执行定时或周期性任务</span></span><br><span class="line"><span class="comment">适用场景：需要单线程顺序执行定时任务 例如: 定时读取文件、定期更新配置文件等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">singleScheduledPool</span> <span class="operator">=</span> Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"><span class="comment">// 按固定频率执行</span></span><br><span class="line">singleScheduledPool.scheduleAtFixedRate(() -&gt; System.out.println(<span class="string">&quot;周期性任务&quot;</span>), <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 按固定延迟执行</span></span><br><span class="line">singleScheduledPool.scheduleWithFixedDelay(() -&gt; System.out.println(<span class="string">&quot;延迟固定间隔任务&quot;</span>), <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上述两个线程池还有一个区别: 如果提交多个任务</span></span><br><span class="line"><span class="comment">scheduledPool会并行执行: 即多个任务在多个线程中周期执行</span></span><br><span class="line"><span class="comment">singleScheduledPool会顺序执行: 即多个任务在一个线程中顺序执行</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-ThreadPoolExecutor"><a href="#2-3-2-ThreadPoolExecutor" class="headerlink" title="2.3.2 ThreadPoolExecutor"></a>2.3.2 ThreadPoolExecutor</h3><p>ThreadPoolExecutor完整的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span>	</span><br></pre></td></tr></table></figure>

<p>代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建自定义线程池</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">2</span>,                      <span class="comment">// corePoolSize</span></span><br><span class="line">                <span class="number">4</span>,                      <span class="comment">// maximumPoolSize</span></span><br><span class="line">                <span class="number">60</span>,                     <span class="comment">// keepAliveTime</span></span><br><span class="line">                TimeUnit.SECONDS,       <span class="comment">// time unit for keepAliveTime</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10</span>),  <span class="comment">// task queue with capacity of 10 tasks</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">CustomThreadFactory</span>(),     <span class="comment">// custom thread factory</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()  <span class="comment">// rejection policy</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">15</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;执行任务: &quot;</span> + taskId);</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);  <span class="comment">// 模拟任务执行时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 被中断&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自定义线程工厂</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CustomThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">            thread.setName(<span class="string">&quot;CustomThread-&quot;</span> + count++);</span><br><span class="line">            <span class="keyword">return</span> thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>任务拒绝策略:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy: 		    丢弃任务并抛出RejectedExecutionException异常。是默认的策略。</span><br><span class="line">ThreadPoolExecutor.DiscardPolicy： 		   丢弃任务，但是不抛出异常 这是不推荐的做法。</span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：    抛弃队列中等待最久的任务(大冤种) 然后把当前任务加入队列中。</span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy:        调用任务的run()方法绕过线程池直接执行。</span><br></pre></td></tr></table></figure>

<p>总结: 一般都是使用 new ThreadPoolExecutor(…)来构造一个线程池</p>
<h1 id="3-内存模型"><a href="#3-内存模型" class="headerlink" title="3. 内存模型"></a>3. 内存模型</h1><h2 id="3-1-JMM"><a href="#3-1-JMM" class="headerlink" title="3.1 JMM"></a>3.1 JMM</h2><p>Java 内存模型（JMM）定义了 Java 程序中多线程访问共享内存时的行为规范，主要解决 <strong>可见性</strong>、<strong>原子性</strong> 和 <strong>有序性</strong> 这三大问题。JMM 是保证并发程序正确性的重要理论基础。</p>
<h3 id="3-1-1-JMM-的核心问题"><a href="#3-1-1-JMM-的核心问题" class="headerlink" title="3.1.1 JMM 的核心问题"></a>3.1.1 JMM 的核心问题</h3><p><strong>可见性问题：</strong><br>一个线程修改了共享变量的值，另一个线程可能无法立即看到最新的值。</p>
<p><strong>原子性问题：</strong><br>一个线程对共享变量的复合操作（如自增）可能被其他线程中断，导致结果错误。</p>
<p><strong>有序性问题：</strong><br>编译器或 CPU 出于优化目的，可能会对代码指令进行重排序，导致程序实际执行顺序与代码顺序不同。</p>
<h3 id="3-1-2-JMM-的三个特性"><a href="#3-1-2-JMM-的三个特性" class="headerlink" title="3.1.2 JMM 的三个特性"></a>3.1.2 JMM 的三个特性</h3><ol>
<li><p>可见性: JMM 保证通过某些方式（如 <code>synchronized</code>、<code>volatile</code>）使得一个线程对共享变量的修改对其他线程可见</p>
</li>
<li><p>原子性: JMM 保证基本数据类型的读取和写入操作是原子的，但复合操作（如自增、自减）不是原子的。</p>
<p> 解决方法:</p>
</li>
</ol>
<ul>
<li><p>使用 <code>synchronized</code></p>
</li>
<li><p>使用 <code>java.util.concurrent</code> 提供的原子类（如 <code>AtomicInteger</code>）</p>
</li>
</ul>
<ol start="3">
<li>有序性: JMM 规定了以下两种规则以约束指令重排</li>
</ol>
<ul>
<li><p><strong>程序顺序规则：</strong> 单线程环境下，代码的执行顺序按照编写顺序执行。</p>
</li>
<li><p><strong>Happens-Before 规则：</strong> 在多线程环境下，JMM 通过定义 “先行发生” 关系来确保操作的顺序性。</p>
</li>
</ul>
<blockquote>
<p>常见的 Happens-Before 规则：</p>
<ol>
<li>程序顺序规则：单线程中，代码顺序以程序代码的先后顺序执行。</li>
<li>锁规则：对一个锁的解锁 Happens-Before 之后对这个锁的加锁。</li>
<li><code>volatile</code> 规则：对一个 <code>volatile</code> 变量的写操作 Happens-Before 后续对这个变量的读操作。</li>
<li>传递性规则：如果操作 A Happens-Before 操作 B，且操作 B Happens-Before 操作 C，则操作 A Happens-Before 操作 C。</li>
</ol>
</blockquote>
<h3 id="3-1-3-JMM-和指令重排"><a href="#3-1-3-JMM-和指令重排" class="headerlink" title="3.1.3 JMM 和指令重排"></a>3.1.3 JMM 和指令重排</h3><p>指令重排的目的是提高程序运行效率，但可能导致意想不到的结果， JMM 通过内存屏障等手段，控制重排的范围，确保多线程程序的正确性。</p>
<p><strong>内存屏障：</strong></p>
<ul>
<li>写屏障：保证写入操作之前的所有操作都已完成。</li>
<li>读屏障：保证读取操作之后的所有操作都不会提前。</li>
</ul>
<h2 id="3-2-volatile的作用"><a href="#3-2-volatile的作用" class="headerlink" title="3.2 volatile的作用"></a>3.2 volatile的作用</h2><h3 id="3-2-1-可见性"><a href="#3-2-1-可见性" class="headerlink" title="3.2.1 可见性"></a>3.2.1 可见性</h3><p><code>volatile</code> 变量会强制从主内存读取变量的最新值，避免线程之间的数据不一致。</p>
<h3 id="3-2-2-禁止指令重排序"><a href="#3-2-2-禁止指令重排序" class="headerlink" title="3.2.2 禁止指令重排序"></a>3.2.2 禁止指令重排序</h3><ol>
<li>指令重排概念: 编译器、JVM 或硬件优化时改变程序中指令的执行顺序, 可能会导致线程间的操作顺序<strong>不符合预期</strong></li>
</ol>
<p>例如: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        num = <span class="number">1</span>;    <span class="comment">// 写操作</span></span><br><span class="line">        flag = <span class="literal">true</span>; <span class="comment">// 写操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            System.out.println(num);  <span class="comment">// 读取操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>两个线程分别调用method和check方法</p>
<p>正常如果进入if语句 num应该是1, 由于指令重排flag先被赋值, num可能为0</p>
<ol start="2">
<li>如何避免</li>
</ol>
<p><code>volatile</code>: </p>
<ul>
<li><p><strong>volatile变量的写操作</strong>：保证该写操作之前的所有操作（无论是当前线程的还是其他线程的）都完成后再执行该写操作。</p>
</li>
<li><p><strong>volatile变量的读操作</strong>：保证该读操作之后的所有操作（无论是当前线程的还是其他线程的）都在读操作后执行。</p>
</li>
</ul>
<p><code>synchronized</code>:</p>
<p>synchronized 确保了同步方法或同步块内部的操作按顺序执行，但它并不是完全避免重排的工具，特别是在涉及到同步外的代码时，仍然可能发生重排</p>
<p><code>final</code>:</p>
<p>线程看到的 final 变量的值一定是初始化后的值</p>
<h3 id="3-2-3-volatile不保证原子性"><a href="#3-2-3-volatile不保证原子性" class="headerlink" title="3.2.3 volatile不保证原子性"></a>3.2.3 volatile不保证原子性</h3><h2 id="3-3-原子性"><a href="#3-3-原子性" class="headerlink" title="3.3 原子性"></a>3.3 原子性</h2><p>原子类的使用场景:</p>
<table>
<thead>
<tr>
<th>原子类</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>AtomicInteger</code> &#x2F; <code>AtomicLong</code></td>
<td>高并发计数器，如访问量统计等</td>
</tr>
<tr>
<td><code>AtomicBoolean</code></td>
<td>状态标志，如标识任务是否已完成</td>
</tr>
<tr>
<td><code>AtomicReference</code></td>
<td>单个引用变量的原子更新</td>
</tr>
<tr>
<td><code>AtomicStampedReference</code></td>
<td>解决 ABA 问题</td>
</tr>
<tr>
<td><code>AtomicIntegerArray</code></td>
<td>数组中元素的高并发修改</td>
</tr>
<tr>
<td><code>LongAdder</code> &#x2F; <code>DoubleAdder</code></td>
<td>高并发累加操作，如实时统计任务执行数</td>
</tr>
</tbody></table>
<h3 id="3-3-1-AtomicInteger原理"><a href="#3-3-1-AtomicInteger原理" class="headerlink" title="3.3.1 AtomicInteger原理"></a>3.3.1 AtomicInteger原理</h3><ol>
<li>是什么:</li>
</ol>
<p>通过 <strong>无锁的 CAS（Compare-And-Swap）机制</strong> 实现线程安全，避免了传统锁带来的性能开销</p>
<ol start="2">
<li>原理</li>
</ol>
<ul>
<li>底层变量存储</li>
</ul>
<p>内部通过 <code>volatile</code> 修饰的 <code>value</code> 变量，确保线程间的可见性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 Unsafe 类实现 CAS</li>
</ul>
<p><code>AtomicInteger</code> 利用了 <code>sun.misc.Unsafe</code> 提供的原子操作支持, Unsafe 提供了硬件级别的原子操作，如 <code>compareAndSwapInt</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 直接由处理器保证。CAS有3个操作数，内存值V，旧的预期值E，要修改的新值U。当且仅当旧预期值E和内存值V相同时，将内存值V修改为U并返回true，否则什么都不做，并返回false。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>内存偏移计算</li>
</ul>
<p>使用 <code>valueOffset</code> 来定位 <code>value</code> 在内存中的位置, <code>Unsafe.objectFieldOffset()</code> 方法返回字段的偏移量，用于操作具体对象的字段</p>
<ol start="3">
<li>常用方法：</li>
</ol>
<ul>
<li><code>incrementAndGet()</code>：自增并返回结果。</li>
<li><code>decrementAndGet()</code>：自减并返回结果。</li>
<li><code>addAndGet(int delta)</code>：增加指定值并返回结果。</li>
<li><code>compareAndSet(int expect, int update)</code>：比较并设置值（CAS）。</li>
<li><code>getAndSet(int newValue)</code>：设置新值并返回旧值。</li>
</ul>
<h3 id="3-3-2-CAS"><a href="#3-3-2-CAS" class="headerlink" title="3.3.2 CAS"></a>3.3.2 CAS</h3><ol>
<li>是什么</li>
</ol>
<p>CAS 是一种无锁的乐观并发控制机制，其核心是一个原子操作指令，通过比较和替换实现数据更新，避免了锁的使用</p>
<p>CAS有3个操作数，内存值V，旧的预期值E，要修改的新值U。当且仅当旧预期值E和内存值V相同时，将内存值V修改为U并返回true，否则什么都不做，并返回false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    当前值 = 内存中的值;</span><br><span class="line">&#125; <span class="keyword">while</span> (!CAS(内存地址, 当前值, 新值));</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>优势</li>
</ol>
<ul>
<li><strong>无锁设计：</strong> CAS 不依赖锁，避免了线程阻塞带来的性能开销</li>
<li><strong>高效：</strong> 由于硬件支持 CAS 指令，执行速度快。</li>
<li><strong>线程安全：</strong> 能够在高并发场景下安全地更新共享变量。</li>
</ul>
<ol start="3">
<li>缺点</li>
</ol>
<ul>
<li><strong>ABA 问题：</strong>变量从 A -&gt; B -&gt; A，CAS 检测不到变化。解决方法：使用版本号，如 <code>AtomicStampedReference</code></li>
<li><strong>自旋开销：</strong>如果多次 CAS 失败，线程会进行自旋重试，导致 CPU 占用率高。</li>
<li><strong>只能操作一个变量：</strong>CAS 只能处理单个共享变量的更新，无法处理多个变量的原子操作。</li>
</ul>
<ol start="4">
<li>ABA问题的解决</li>
</ol>
<p>问题描述：假设线程 T1 和线程 T2 操作同一个变量：</p>
<ol>
<li>T1 读取变量值为 A，准备更新为 B。</li>
<li>T2 将变量从 A 改为 C，再改回 A。</li>
<li>T1 检测到变量值仍是 A，认为值没有变化，成功更新为 B。</li>
</ol>
<p>解决方案：<strong>使用 AtomicStampedReference：</strong> 引入版本号或标记，确保变量的逻辑连续性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 100：初始值 0：初始版本号（或称“标记”）。</span></span><br><span class="line">AtomicStampedReference&lt;Integer&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前stamp值</span></span><br><span class="line"><span class="type">int</span>[] stamp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line"><span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> ref.get(stamp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 CAS 更新值和版本号</span></span><br><span class="line">ref.compareAndSet(value, <span class="number">200</span>, stamp[<span class="number">0</span>], stamp[<span class="number">0</span>] + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>总结: CAS是一种乐观锁</p>
<h1 id="4-并发工具类"><a href="#4-并发工具类" class="headerlink" title="4. 并发工具类"></a>4. 并发工具类</h1><h2 id="4-1-ConcurrentHashMap"><a href="#4-1-ConcurrentHashMap" class="headerlink" title="4.1 ConcurrentHashMap"></a>4.1 ConcurrentHashMap</h2><h3 id="4-1-1-HashMap的问题"><a href="#4-1-1-HashMap的问题" class="headerlink" title="4.1.1 HashMap的问题"></a>4.1.1 HashMap的问题</h3><p>在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。</p>
<p>基于以上两个原因我们可以使用JDK1.5以后所提供的ConcurrentHashMap。</p>
<p><font color="blue" size="3"><strong>案例1</strong></font>：演示HashMap线程不安全</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个HashMap集合对象</span></span><br><span class="line">        HashMap&lt;String , String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String , String&gt;() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建两个线程对象,我们本次使用匿名内部类的方式去常见线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 第一个线程对象向集合中添加元素(1-24)</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span> ; x &lt; <span class="number">25</span> ; x++) &#123;</span><br><span class="line">                    hashMap.put(String.valueOf(x) , String.valueOf(x)) ;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程t2</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 第二个线程对象向集合中添加元素(25-50)</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">25</span> ; x &lt; <span class="number">51</span> ; x++) &#123;</span><br><span class="line">                    hashMap.put(String.valueOf(x) , String.valueOf(x)) ;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 主线程休眠2s，以便让其他两个线程将数据填装完毕</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从集合中找出键和值不相同的数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span> ; x &lt; <span class="number">51</span> ; x++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// HashMap中的键就是当前循环变量的x这个数据的字符串表现形式 ， 根据键找到值，然后在进行判断</span></span><br><span class="line">            <span class="keyword">if</span>( !String.valueOf(x).equals( hashMap.get(String.valueOf(x)) ) ) &#123;</span><br><span class="line">                System.out.println(String.valueOf(x) + <span class="string">&quot;:&quot;</span> + hashMap.get(String.valueOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------------</span><br><span class="line"><span class="number">5</span>:<span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>通过控制台的输出结果，我们可以看到在多线程操作HashMap的时候，可能会出现线程安全问题。</p>
<p>ConcurrentHashMap不会出现这个问题</p>
<h3 id="4-1-2-ConcurrentHashMap介绍"><a href="#4-1-2-ConcurrentHashMap介绍" class="headerlink" title="4.1.2 ConcurrentHashMap介绍"></a>4.1.2 ConcurrentHashMap介绍</h3><p><code>ConcurrentHashMap</code> 是 Java 并发包中用于高效处理并发情况下的线程安全哈希表。其核心思想是 <strong>分段锁（Segment Locking）</strong> 在早期版本中实现了更细粒度的锁机制，而在 JDK 8 中进行了优化，通过 <strong>CAS（Compare-And-Swap）</strong> 和 <strong>Node 链表+红黑树</strong> 提升了并发性能。</p>
<p><strong>核心设计思想</strong></p>
<ol>
<li><strong>分段锁（JDK 7 及以前）</strong>：<ul>
<li>整个表被分成多个 <code>Segment</code>，每个 <code>Segment</code> 类似于一个小的哈希表，拥有独立的锁。</li>
<li>并发操作只需锁定相关的 <code>Segment</code>，减少了锁的争用。</li>
</ul>
</li>
<li><strong>CAS + 紧凑结构（JDK 8 后）</strong>：<ul>
<li>弃用了 <code>Segment</code>，改用 <code>Node</code> 链表结构（必要时转换为红黑树）。</li>
<li>使用 CAS 来保证多线程环境下的无锁操作（如插入新节点）。</li>
<li>引入 <code>synchronized</code> 锁定特定桶（链表头或树根）以处理复杂情况（如扩容、链表转红黑树）。</li>
</ul>
</li>
</ol>
<h3 id="4-1-3-源码介绍"><a href="#4-1-3-源码介绍" class="headerlink" title="4.1.3 源码介绍"></a>4.1.3 源码介绍</h3><h4 id="jdk1-7版本"><a href="#jdk1-7版本" class="headerlink" title="jdk1.7版本"></a>jdk1.7版本</h4><p><font color="blue" size="3"><strong>ConcurrentHashMap中的重要成员变量</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMap</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">ConcurrentMap</span>&lt;K, V&gt;, Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Segment翻译中文为&quot;段&quot; , 段数组对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Segment是一种可重入锁（ReentrantLock），在ConcurrentHashMap里扮演锁的角色，将一个大的table分割成多个小的table进行加锁。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> count;    			<span class="comment">// Segment中元素的数量，由volatile修饰，支持内存可见性；</span></span><br><span class="line">        <span class="keyword">transient</span> <span class="type">int</span> modCount;			 			<span class="comment">// 对table的大小造成影响的操作的数量（比如put或者remove操作）;</span></span><br><span class="line">        <span class="keyword">transient</span> <span class="type">int</span> threshold;		 			<span class="comment">// 扩容阈值;</span></span><br><span class="line">        <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;  <span class="comment">// 链表数组，数组中的每一个元素代表了一个链表的头部;</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">float</span> loadFactor;			 			<span class="comment">// 负载因子 </span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Segment中的元素是以HashEntry的形式存放在数组中的，其结构与普通HashMap的HashEntry基本一致，不同的是Segment的HashEntry，其value由		     // volatile修饰，以支持内存可见性，即写操作对其他读线程即时可见。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HashEntry</span>&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;					<span class="comment">// 当前节点key对应的哈希码值</span></span><br><span class="line">        <span class="keyword">final</span> K key;					<span class="comment">// 存储键</span></span><br><span class="line">        <span class="keyword">volatile</span> V value;				<span class="comment">// 存储值</span></span><br><span class="line">        <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;	<span class="comment">// 下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单来讲，就是ConcurrentHashMap比HashMap多了一次hash过程，第1次hash定位到Segment，第2次hash定位到HashEntry，然后链表搜索找到指定节点。</p>
<p>在进行写操作时，只需锁住写元素所在的Segment即可(这种锁被称为<font size="3" color="red"><strong>分段锁</strong></font>)，其他Segment无需加锁，从而产生锁竞争的概率大大减小，提高了并发读写的效率。</p>
<p>该种实现方式的缺点是hash过程比普通的HashMap要长(因为需要进行两次hash操作)。</p>
<p><font size="3" color="blue"><strong>ConcurrentHashMap的put方法源码分析</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMap</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">ConcurrentMap</span>&lt;K, V&gt;, Serializable &#123; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义一个Segment对象</span></span><br><span class="line">        Segment&lt;K,V&gt; s;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果value的值为空，那么抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// hash函数获取key的hashCode，然后做了一些处理</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过key的hashCode定位segment</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对定位的Segment进行判断，如果Segment为空，调用ensureSegment进行初始化操作(第一次hash定位)</span></span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject(segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="literal">null</span>) </span><br><span class="line">            s = ensureSegment(j);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用Segment对象的put方法添加元素</span></span><br><span class="line">        <span class="keyword">return</span> s.put(key, hash, value, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Segment是一种可ReentrantLock，在ConcurrentHashMap里扮演锁的角色，将一个大的table分割成多个小的table进行加锁。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        <span class="keyword">final</span> V <span class="title function_">put</span><span class="params">(K key, <span class="type">int</span> hash, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 尝试对该段进行加锁,如果加锁失败，则调用scanAndLockForPut方法;在该方法中就要进行再次尝试或者进行自旋等待</span></span><br><span class="line">            HashEntry&lt;K,V&gt; node = tryLock() ? <span class="literal">null</span> : scanAndLockForPut(key, hash, value);</span><br><span class="line">            V oldValue;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 获取HashEntry数组对象</span></span><br><span class="line">                HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 根据key的hashCode值计算索引(第二次hash定位)</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) </span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 若不为null</span></span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                        K k;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 判读当前节点的key是否和链表头节点的key相同(依赖于hashCode方法和equals方法) </span></span><br><span class="line">                        <span class="comment">// 如果相同，值进行更新</span></span><br><span class="line">                        <span class="keyword">if</span> ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                            oldValue = e.value;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                                e.value = value;</span><br><span class="line">                                ++modCount;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        e = e.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 若头结点为null</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 将新节点添加到链表中</span></span><br><span class="line">                        <span class="keyword">if</span> (node != <span class="literal">null</span>) </span><br><span class="line">                            node.setNext(first);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            node = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> count + <span class="number">1</span>;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 如果超过阈值，则进行rehash操作</span></span><br><span class="line">                        <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                            rehash(node);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            setEntryAt(tab, index, node);</span><br><span class="line">                        ++modCount;</span><br><span class="line">                        count = c;</span><br><span class="line">                        oldValue = <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125; 	</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：简单了解即可(核心：进行了两次哈希定位以及加锁过程)</p>
</blockquote>
<h4 id="jdk1-8版本"><a href="#jdk1-8版本" class="headerlink" title="jdk1.8版本"></a>jdk1.8版本</h4><p>在JDK1.8中为了进一步优化ConcurrentHashMap的性能，去掉了Segment分段锁的设计。在数据结构方面，则是跟HashMap一样，使用一个哈希表table数组。(数组 + 链表 + 红黑树) </p>
<p>而线程安全方面是结合CAS机制 + 局部锁实现的，减低锁的粒度，提高性能。同时在HashMap的基础上，对哈希表table数组和链表节点的value，next指针等使用volatile来修饰，从而实现线程可见性。</p>
<p><font color="blue" size="3"><strong>ConcurrentHashMap中的重要成员变量</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">ConcurrentMap</span>&lt;K,V&gt;, Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Node数组</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Node类的定义</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;				<span class="comment">// 当前key的hashCode值</span></span><br><span class="line">        <span class="keyword">final</span> K key;				<span class="comment">// 键</span></span><br><span class="line">        <span class="keyword">volatile</span> V val;				<span class="comment">// 值</span></span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;	<span class="comment">// 下一个节点</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// TreeNode类的定义</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// 父节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;	   <span class="comment">// 左子节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; right;   <span class="comment">// 右子节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="type">boolean</span> red;		   <span class="comment">// 节点的颜色状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="blue" size="3"><strong>ConcurrentHashMap的put方法源码分析</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">ConcurrentMap</span>&lt;K,V&gt;, Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// putVal方法定义</span></span><br><span class="line">    <span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// key为null直接抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算key所对应的hashCode值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">        <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 哈希表如果不存在，那么此时初始化哈希表</span></span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                tab = initTable();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 通过hash值计算key在table表中的索引，将其值赋值给变量i,然后根据索引找到对应的Node，如果Node为null,做出处理</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 新增链表头结点，cas方式添加到哈希表table</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>))) <span class="keyword">break</span>;                   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// f为链表头结点，使用synchronized加锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                                K ek;</span><br><span class="line">                                </span><br><span class="line">                                <span class="comment">// 节点已经存在，更新value即可</span></span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                </span><br><span class="line">                                <span class="comment">// 该key对应的节点不存在,则新增节点并添加到该链表的末尾</span></span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                    pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                </span><br><span class="line">                            &#125;</span><br><span class="line">                            </span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123; <span class="comment">// 红黑树节点，则往该红黑树更新或添加该节点即可</span></span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 判断是否需要将链表转为红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// CAS算法的核心类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe U;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原子获取链表节点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="title function_">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// CAS更新或新增链表节点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单总结：</p>
<ol>
<li><p>如果当前需要put的key对应的链表在哈希表table中还不存在，即还没添加过该key的hash值对应的链表，则调用casTabAt方法，基于CAS机制来实现添加该链表头结点到哈希表table中，避免该线程在添加该链表头结的时候，其他线程也在添加的并发问题；如果CAS失败，则进行自旋，通过则继续第2步的操作；</p>
</li>
<li><p>如果需要添加的链表已经存在哈希表table中，则通过tabAt方法，基于volatile机制，获取当前最新的链表头结点f，由于f指向的是ConcurrentHashMap的哈希表table的某条链表的头结点，故虽然f是临时变量，由于是引用共享的该链表头结点，所以可以使用synchronized关键字来同步多个线程对该链表的访问。在synchronized(f)同步块里面则是与HashMap一样遍历该链表，如果该key对应的链表节点已经存在，则更新，否则在链表的末尾新增该key对应的链表节点。</p>
</li>
</ol>
<h2 id="4-2-CountDownLatch"><a href="#4-2-CountDownLatch" class="headerlink" title="4.2 CountDownLatch"></a>4.2 CountDownLatch</h2><p>减法计数器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCountDownLatch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;   Go Out&quot;</span>);</span><br><span class="line">                countDownLatch.countDown(); <span class="comment">// count-1</span></span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await(); <span class="comment">// 等待count为零才继续执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Close the door&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-CyclicBarrier"><a href="#4-3-CyclicBarrier" class="headerlink" title="4.3 CyclicBarrier"></a>4.3 CyclicBarrier</h2><p>加法计数器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCyclicBarrier</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">7</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;召唤神龙&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;成功获取到第&quot;</span> + temp + <span class="string">&quot;颗龙珠&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-4-Semaphore"><a href="#4-4-Semaphore" class="headerlink" title="4.4 Semaphore"></a>4.4 Semaphore</h2><p>共享资源互斥的使用, 并发限流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySemaphore</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>); <span class="comment">// 三个停车位 限流</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(temp + <span class="string">&quot;号车停在了车位&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    System.out.println(temp + <span class="string">&quot;号车离开了车位&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Sanjin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/12/01/HelloW/">http://example.com/2023/12/01/HelloW/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Sanjin Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Sanjin</div><div class="author-info-description">小菜鸡一枚</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">1</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.</span> <span class="toc-text">1. 线程状态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 线程状态:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 线程状态之间的转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 实例代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.</span> <span class="toc-text">2. 线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 自定义线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E8%B7%9F%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%9E%8B%E7%B1%BB%E4%BC%BC-%EF%BC%9A"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1 线程池的工作原理(跟生产消费模型类似)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2 代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-JDK%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 JDK中的线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-Executors"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1 Executors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-ThreadPoolExecutor"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2 ThreadPoolExecutor</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">3. 内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-JMM"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 JMM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-JMM-%E7%9A%84%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1 JMM 的核心问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-JMM-%E7%9A%84%E4%B8%89%E4%B8%AA%E7%89%B9%E6%80%A7"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2 JMM 的三个特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-JMM-%E5%92%8C%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.1.3 JMM 和指令重排</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-volatile%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 volatile的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1 可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2 禁止指令重排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-volatile%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3 volatile不保证原子性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 原子性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-AtomicInteger%E5%8E%9F%E7%90%86"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1 AtomicInteger原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-CAS"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.3.2 CAS</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">4. 并发工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-ConcurrentHashMap"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-HashMap%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1 HashMap的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-ConcurrentHashMap%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.1.2.</span> <span class="toc-text">4.1.2 ConcurrentHashMap介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-%E6%BA%90%E7%A0%81%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.1.3.</span> <span class="toc-text">4.1.3 源码介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk1-7%E7%89%88%E6%9C%AC"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">jdk1.7版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk1-8%E7%89%88%E6%9C%AC"><span class="toc-number">4.1.3.2.</span> <span class="toc-text">jdk1.8版本</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-CountDownLatch"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 CountDownLatch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-CyclicBarrier"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 CyclicBarrier</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-Semaphore"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 Semaphore</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><div class="content"><a class="title" href="/2023/12/01/HelloW/" title="HelloW">HelloW</a><time datetime="2023-11-30T16:07:05.000Z" title="发表于 2023-12-01 00:07:05">2023-12-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By Sanjin</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>